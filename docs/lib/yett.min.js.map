{"version":3,"file":"yett.min.js","sources":["../../src/checks.js","../../src/variables.js","../../src/observer.js","../../src/monkey.js","../../src/unblock.js"],"sourcesContent":["import { patterns, TYPE_ATTRIBUTE } from './variables'\nconst loggedBlacklist = [];\n\nexport const isOnBlacklist = (src, type) => {\n    const onBlacklist = src &&\n    (!type || type !== TYPE_ATTRIBUTE) &&\n    (\n        (!patterns.blacklist || patterns.blacklist.some(pattern => pattern.test(src))) &&\n        (!patterns.whitelist || patterns.whitelist.every(pattern => !pattern.test(src)))\n    );\n\n\n    if(onBlacklist && loggedBlacklist.indexOf(src) === -1){\n        loggedBlacklist.push(src);\n        console.info(`Script src '${src}' is blocked`);\n    }\n\n    return onBlacklist;\n}\n\nexport const willBeUnblocked = function(script) {\n    const src = script.getAttribute('src')\n    return (\n        patterns.blacklist && patterns.blacklist.every(entry => !entry.test(src)) ||\n        patterns.whitelist && patterns.whitelist.some(entry => entry.test(src))\n    )\n}","export const TYPE_ATTRIBUTE = 'javascript/blocked'\nexport const UNBLOCK_INLINESCRIPTS = window.YETT_UNBLOCKINLINE || false\n\nexport const patterns = {\n    blacklist: window.YETT_BLACKLIST,\n    whitelist: window.YETT_WHITELIST\n}\n\n// Backup list containing the original blacklisted script elements\nexport const backupScripts = {\n    blacklisted: []\n}\nexport const backupIframes = {\n    blacklisted: []\n}","import { backupScripts, backupIframes, TYPE_ATTRIBUTE } from './variables'\nimport { isOnBlacklist } from './checks'\n\n// Setup a mutation observer to track DOM insertion\nexport const observer = new MutationObserver(mutations => {\n    for (let i = 0; i < mutations.length; i++) {\n        const { addedNodes } = mutations[i];\n        for(let i = 0; i < addedNodes.length; i++) {\n            const node = addedNodes[i]\n            // For each added script tag\n\n\n            if(node.nodeType === 1 && [ 'SCRIPT', 'IFRAME' ].indexOf(node.tagName) > -1 && !node.hasAttribute('data-noblock')) {\n                const src = node.src\n                const type = node.tagName === 'SCRIPT' ? node.type : 'text/javascript';\n                // If the src is inside the blacklist and is not inside the whitelist\n                if(isOnBlacklist(src, type)) {\n                    // We backup a copy of the script node\n                    if(node.tagName === 'SCRIPT'){\n                        backupScripts.blacklisted.push(node.cloneNode())\n                    } else {\n                        backupIframes.blacklisted.push(node.cloneNode())\n                    }\n\n                    // Blocks inline script execution in Safari & Chrome\n                    node.type = TYPE_ATTRIBUTE\n\n                    // Firefox has this additional event which prevents scripts from beeing executed\n                    const beforeScriptExecuteListener = function (event) {\n                        // Prevent only marked scripts from executing\n                        if(node.getAttribute('type') === TYPE_ATTRIBUTE)\n                            event.preventDefault()\n                        node.removeEventListener('beforescriptexecute', beforeScriptExecuteListener)\n                    }\n                    node.addEventListener('beforescriptexecute', beforeScriptExecuteListener)\n\n                    // Remove the node from the DOM\n                    if(node.tagName === 'SCRIPT'){\n                        node.parentElement && node.parentElement.removeChild(node)\n                    } else {\n                        node.setAttribute('data-blocked-src', node.src);\n                        node.setAttribute('src', 'about:blank');\n                    }\n                }\n            }\n        }\n    }\n})\n\n// Starts the monitoring\nobserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true\n})","import { TYPE_ATTRIBUTE } from './variables'\nimport { isOnBlacklist } from './checks'\n\nconst createElementBackup = document.createElement\n\n// Monkey patch the createElement method to prevent dynamic scripts from executing\ndocument.createElement = function(...args) {\n    // If this is not a script tag, bypass\n    // if(args[0].toLowerCase() !== 'script')\n    const nodeType = args[0].toLowerCase();\n    if(['script', 'iframe'].indexOf(nodeType) === -1 )\n        return createElementBackup.bind(document)(...args)\n\n    const scriptElt = createElementBackup.bind(document)(...args)\n    const originalSetAttribute = scriptElt.setAttribute.bind(scriptElt)\n\n    const type = nodeType === 'script' ? scriptElt.type : 'text/javascript';\n    // Define getters / setters to ensure that the script type is properly set\n    try {\n        Object.defineProperties(scriptElt, {\n            'src': {\n                get() {\n                    return scriptElt.getAttribute('src')\n                },\n                set(value) {\n\n                    if(isOnBlacklist(value, type) && !scriptElt.hasAttribute('data-noblock')) {\n                        originalSetAttribute('type', TYPE_ATTRIBUTE)\n                    }\n                    originalSetAttribute('src', value)\n                    return true\n                }\n            },\n            'type': {\n                set(value) {\n                    const typeValue =\n                        isOnBlacklist(scriptElt.src, type) && !scriptElt.hasAttribute('data-noblock') ?\n                            TYPE_ATTRIBUTE :\n                        value\n                    originalSetAttribute('type', typeValue)\n                    return true\n                }\n            }\n        })\n\n        // Monkey patch the setAttribute function so that the setter is called instead\n        scriptElt.setAttribute = function(name, value) {\n            if(name === 'type' || name === 'src')\n                scriptElt[name] = value\n            else\n                if(type === 'script'){\n                    HTMLScriptElement.prototype.setAttribute.call(scriptElt, name, value)\n                } else {\n                    HTMLIFrameElement.prototype.setAttribute.call(scriptElt, name, value)\n                }\n        }\n    } catch (error) {\n        console.warn(\n            'Yett: unable to prevent script execution for script src ', scriptElt.src, '.\\n',\n            'A likely cause would be because you are using a third-party browser extension that monkey patches the \"document.createElement\" function.'\n        )\n    }\n\n    return scriptElt\n}","import {\n    patterns,\n    backupScripts,\n    backupIframes,\n    TYPE_ATTRIBUTE,\n    UNBLOCK_INLINESCRIPTS\n} from './variables'\n\nimport {\n    willBeUnblocked\n} from './checks'\n\nimport {\n    observer\n} from './observer'\n\nconst URL_REPLACER_REGEXP = new RegExp('[|\\\\{}()[\\\\]^$+*?.]', 'g')\n\n// Unblocks all (or a selection of) blacklisted scripts.\nexport const unblock = function(...scriptUrlsOrRegexes) {\n    if(scriptUrlsOrRegexes.length < 1) {\n        patterns.blacklist = []\n        patterns.whitelist = []\n    } else {\n        if(patterns.blacklist) {\n            patterns.blacklist = patterns.blacklist.filter(pattern => (\n                scriptUrlsOrRegexes.every(urlOrRegexp => {\n                    if(typeof urlOrRegexp === 'string')\n                        return !pattern.test(urlOrRegexp)\n                    else if(urlOrRegexp instanceof RegExp)\n                        return pattern.toString() !== urlOrRegexp.toString()\n                })\n            ))\n        }\n        if(patterns.whitelist) {\n            patterns.whitelist = [\n                ...patterns.whitelist,\n                ...scriptUrlsOrRegexes\n                    .map(urlOrRegexp => {\n                        if(typeof urlOrRegexp === 'string') {\n                            const escapedUrl = urlOrRegexp.replace(URL_REPLACER_REGEXP, '\\\\$&')\n                            const permissiveRegexp = '.*' + escapedUrl + '.*'\n                            if(patterns.whitelist.every(p => p.toString() !== permissiveRegexp.toString())) {\n                                return new RegExp(permissiveRegexp)\n                            }\n                        } else if(urlOrRegexp instanceof RegExp) {\n                            if(patterns.whitelist.every(p => p.toString() !== urlOrRegexp.toString())) {\n                                return urlOrRegexp\n                            }\n                        }\n                        return null\n                    })\n                    .filter(Boolean)\n            ]\n        }\n    }\n\n\n    // Parse existing script tags with a marked type\n    const tags = document.querySelectorAll(`script[type=\"${TYPE_ATTRIBUTE}\"]`)\n    for(let i = 0; i < tags.length; i++) {\n        const script = tags[i]\n        if(willBeUnblocked(script)) {\n            script.type = 'application/javascript'\n            backupScripts.blacklisted.push(script)\n            script.parentElement.removeChild(script)\n        }\n    }\n\n    // Parse existing iframe tags with a marked type\n    const iframeTags = document.querySelectorAll(`iframe[type=\"${TYPE_ATTRIBUTE}\"]`)\n    for(let i = 0; i < iframeTags.length; i++) {\n        const script = iframeTags[i]\n        if(willBeUnblocked(script)) {\n            script.type = 'application/javascript'\n            backupIframes.blacklisted.push(script)\n            script.parentElement.removeChild(script)\n        }\n    }\n\n    // Exclude 'whitelisted' scripts from the blacklist and append them to <head>\n    let indexOffset = 0;\n    [...backupScripts.blacklisted].forEach((script, index) => {\n        if(willBeUnblocked(script)) {\n            const scriptNode = document.createElement('script')\n            scriptNode.setAttribute('src', script.src)\n            scriptNode.setAttribute('type', 'application/javascript')\n            document.head.appendChild(scriptNode)\n            backupScripts.blacklisted.splice(index - indexOffset, 1)\n            indexOffset++\n        }\n    })\n\n    // let iframeIndexOffset = 0;\n    // [...backupIframes.blacklisted].forEach((iframe, index) => {\n    //     if(willBeUnblocked(iframe)) {\n    //         const iframeNode = document.createElement('iframe')\n    //         iframeNode.setAttribute('src', iframe.src)\n    //         document.head.appendChild(iframeNode)\n    //         backupIframes.blacklisted.splice(index - iframeIndexOffset, 1)\n    //         iframeIndexOffset++\n    //     }\n    // })\n\n    // Disconnect the observer if the blacklist is empty for performance reasons\n    if(patterns.blacklist && patterns.blacklist.length < 1) {\n        observer.disconnect()\n    }\n\n    //If we have javascript/inlineblocked inline scripts ( without a src ) unblock those as well.\n    if( UNBLOCK_INLINESCRIPTS ) {\n        [...document.querySelectorAll('script[type=\"javascript/inlineblocked\"]')].forEach( script => {\n            const newScript = document.createElement('script');\n            newScript.type = 'text/javascript';\n            newScript.innerText = script.innerText;\n            script.parentNode.replaceChild(newScript, script);\n        });\n\n        [...document.querySelectorAll('iframe[data-blocked-src]')].forEach( iframe => {\n            const newIframe = document.createElement('iframe');\n            newIframe.src = iframe.getAttribute('data-blocked-src');\n            iframe.parentNode.replaceChild(newIframe, iframe);\n        });\n    }\n}"],"names":["isOnBlacklist","src","type","onBlacklist","TYPE_ATTRIBUTE","patterns","blacklist","some","pattern","test","whitelist","every","loggedBlacklist","indexOf","push","console","info","willBeUnblocked","script","getAttribute","entry","UNBLOCK_INLINESCRIPTS","window","YETT_UNBLOCKINLINE","YETT_BLACKLIST","YETT_WHITELIST","backupScripts","blacklisted","backupIframes","observer","MutationObserver","mutations","i","length","addedNodes","node","nodeType","tagName","hasAttribute","cloneNode","addEventListener","beforeScriptExecuteListener","event","preventDefault","removeEventListener","parentElement","removeChild","setAttribute","observe","document","documentElement","childList","subtree","createElementBackup","createElement","args","toLowerCase","bind","scriptElt","originalSetAttribute","Object","defineProperties","get","set","value","typeValue","name","HTMLScriptElement","prototype","call","HTMLIFrameElement","error","warn","URL_REPLACER_REGEXP","RegExp","scriptUrlsOrRegexes","filter","urlOrRegexp","toString","map","permissiveRegexp","replace","p","Boolean","tags","querySelectorAll","iframeTags","indexOffset","forEach","index","scriptNode","head","appendChild","splice","disconnect","newScript","innerText","parentNode","replaceChild","iframe","newIframe"],"mappings":"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"}